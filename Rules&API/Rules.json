{
  "rules": {
    "core_includes": {
      "description": "MCAL.h file must begin with all required `#include` statements. This includes the core MCU header file (like stm32f4xx.h or device-specific header), and standard C library includes if any standard functions are used. If unsure which device header to include, insert a placeholder with a comment.",
      "examples": [
          "#include \"stm32f401xc.h\"  // Core device header",
          "#include <stdint.h>",
          "#include <stdbool.h>",
          "#include <stddef.h>",
          "#include <string.h>",
          "#include <stdio.h>",
          "#include <stdlib.h>",
          "#include <math.h>"
        ]
    },
    "peripheral_enable_rules": {
      "description": "Ensure that all Enable functions also enable the peripheral clock in RCC or equivalent before setting the peripheral's main enable bit.",
      "rules": [
        "When generating any function with a name starting with 'Enable', first locate the corresponding clock enable register in register_json (e.g., RCC_APB2ENR for ADC, RCC_APB1ENR for UART).",
        "If found, set the correct bit to enable the peripheral clock before setting the peripheral's enable bit (e.g., ADON for ADC, UE for UART).",
        "If not found in register_json, attempt to deduce the register name and bit position based on MCU conventions (e.g., STM32: ADC1 → RCC_APB2ENR bit 8, USART1 → RCC_APB2ENR bit 4, USART2 → RCC_APB1ENR bit 17).",
        "Insert the deduced register and bit as working code, followed by a comment indicating it was inferred.",
        "Always call WDT_Reset() before enabling the clock or setting the enable bit."
      ]
    },
    "sleep_mode_definition": {
      "description": "Sleep mode stops executing code and peripherals (except OS timer)",
      "example": "For HOLTEK HT46R24: _halt();"
    },
    "file_structure": {
      "description": "Build MCAL Layer contains 2 Files (.h) and (.c)",
      "details": {
        "header_file": {
          "purpose": "Include APIs & type definitions",
          "example": "typedef enum { Vsource_3V = 0, Vsource_5V } t_sys_volt_type; void MCU_Config_Init(t_sys_volt sys_volt);"
        },
        "source_file": {
          "purpose": "Implementation of API bodies"
        }
      }
    },
    "LVD_requirements": {
      "description": "LOW VOLTAGE DETECTION (LVD) threshold levels",
      "levels": ["Volt_0.5V", "Volt_1V", "Volt_1.5V", "Volt_2V", "...", "Volt_5V"]
    },
    "MCU_Config_Init_implementation": {
      "steps": [
        "Set all GPIO pins to 0 and verify with while loop",
        "Set all GPIO pins direction to input and verify with while loop",
        "Disable all features (global interrupt, ADC, UART, I2S, SPI, TIMER, etc.)",
        "Enable WDT (Watchdog Timer)",
        "Clear WDT timer",
        "Set WDT period >= 8 msec",
        "Set LOW Voltage Reset value based on system voltage (2V for 3V, 3.5V for 5V)",
        "Enable LVR (Low Voltage Reset)",
        "Clear WDT again"
      ]
    },
    "API_implementation_sequence": {
      "description": "Start with WDT_Reset() implementation, then implement other APIs",
      "rule": "All API bodies must include WDT_Reset() as code not comment"
    },
    "API_naming_conventions": {
      "allowed_prefixes": [
        "Init (initialization)",
        "Set (set data)",
        "Get (get data)",
        "Update (update status each period)",
        "Enable (enable interrupt)",
        "Disable (disable interrupt)",
        "Start (start processing if enabled)",
        "Stop (stop processing if enabled)"
      ]
    },
    "data_type_definitions": {
      "rules": [
        "#define Unit_8 tbyte",
        "#define unit_16 tword",
        "#define unit_32 tlong"
      ]
    },
    "I2C_rules": {
      "rules": [
        "Addressing Mode equals Device Address",
        "Always use fast mode",
        "Always use maximum timeout",
        "Always generate a repeated start condition instead of stop between transactions"
      ]
    },
    "SPI_rules": {
      "rules": [
        "CPHA: Clock Phase",
        "DFF: Data Frame Format",
        "Always use fast speed",
        "Slave Select always software-controlled",
        "Always use full duplex",
        "Always enable CRC"
      ]
    },
    "GPIO_rules": {
      "rules": [
        "After setting GPIO direction, verify with while loop",
        "After setting GPIO value, verify with while loop",
        "All input pins have pull-up resistors and wakeup feature enabled (if available)",
        "All output pins have pull-up resistors disabled",
        "For current registers: use >=20mA sink current & >=10mA source current",
        "Always set value before setting direction"
      ]
    },
    "coding_standards": {
      "standards": [
        "MISRA C",
        "CERT-C"
      ]
    },
    "PWM_requirements": {
      "description": "PWM initialization requirements",
      "rule": "Clear available FREQUENCY Ranges for each channel as comments in PWM_Init()"
    },
    "ICU_usage": {
      "description": "ICU API usage",
      "functions": [
        "Get frequency when edge happens",
        "Get remote control pressed key based on updated parameters"
      ]
    },
    "RTOS_requirements": {
      "description": "Code must be compatible with RTOS or Time Triggered OS",
      "rules": [
        "Minimize use of interrupts",
        "Avoid causing any timer delays"
      ]
    },
    "commenting_requirements": {
      "description": "Commenting standards",
      "rules": [
        "Clearly relate pin numbers to functions",
        "Example: PWM_Channel_TIM1_CH1 //PA8,PE9"
      ]
    }
  }
}